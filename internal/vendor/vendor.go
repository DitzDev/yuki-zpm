package vendor

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"yuki_zpm.org/logger"
	"yuki_zpm.org/manifest"
)

const (
	VendorDir = "yuki_modules"
	YukiZigFile = "yuki.zig"
	BuildZigFile = "build.zig"
)

type Vendorer struct{}

func New() *Vendorer {
	return &Vendorer{}
}

func (v *Vendorer) VendorDependency(name, sourcePath, projectRoot string) error {
	vendorPath := filepath.Join(projectRoot, VendorDir, name)

	if err := os.RemoveAll(vendorPath); err != nil {
		return fmt.Errorf("failed to remove existing vendor directory: %w", err)
	}

	if err := os.MkdirAll(filepath.Dir(vendorPath), 0755); err != nil {
		return fmt.Errorf("failed to create vendor directory: %w", err)
	}
	
	if err := copyDir(sourcePath, vendorPath); err != nil {
		return fmt.Errorf("failed to copy dependency: %w", err)
	}
	
	logger.Debug("Vendored dependency '%s' to %s", name, vendorPath)
	return nil
}

func (v *Vendorer) GenerateYukiZig(projectRoot string, lockFile *manifest.LockFile, projectManifest *manifest.Manifest) error {
	yukiZigPath := filepath.Join(projectRoot, YukiZigFile)
	
	content := v.generateYukiZigContent(lockFile, projectManifest)
	
	if err := os.WriteFile(yukiZigPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write yuki.zig: %w", err)
	}
	
	logger.Debug("Generated %s", YukiZigFile)
	return nil
}

func (v *Vendorer) UpdateBuildZig(projectRoot string, lockFile *manifest.LockFile, projectManifest *manifest.Manifest) error {
	buildZigPath := filepath.Join(projectRoot, BuildZigFile)

	if _, err := os.Stat(buildZigPath); os.IsNotExist(err) {
		logger.Warn("build.zig not found, skipping build.zig update")
		return nil
	}

	content, err := os.ReadFile(buildZigPath)
	if err != nil {
		return fmt.Errorf("failed to read build.zig: %w", err)
	}

	updatedContent, err := v.updateBuildZigContent(string(content), lockFile, projectManifest)
	if err != nil {
		return fmt.Errorf("failed to update build.zig content: %w", err)
	}

	if err := os.WriteFile(buildZigPath, []byte(updatedContent), 0644); err != nil {
		return fmt.Errorf("failed to write updated build.zig: %w", err)
	}

	logger.Debug("Updated %s with dependencies", BuildZigFile)
	return nil
}

func (v *Vendorer) removeAutoGeneratedContent(content string) string {
	lines := strings.Split(content, "\n")
	var result []string
	inAutoSection := false
	skipEmptyLines := 0
	
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		if strings.Contains(line, `const yuki = @import("yuki.zig");`) {
			continue
		}
		if strings.Contains(line, "// Auto-generated dependencies by Yuki") {
			inAutoSection = true
			continue
		}
		
		if inAutoSection {
			if strings.Contains(line, ".root_module.addImport") || 
			   strings.Contains(line, ".createModule") || 
			   strings.Contains(line, ".root_source_file") ||
			   strings.Contains(line, "b.path(\"yuki_modules/") {
				continue
			}
		
			if trimmed == "}));" {
				continue
			}
			
			if trimmed == "" {
				skipEmptyLines = 1 
				inAutoSection = false
				continue
			}
	
			inAutoSection = false
		}
	
		if skipEmptyLines > 0 && trimmed == "" {
			skipEmptyLines--
			continue
		}
	
		if trimmed != "" {
			skipEmptyLines = 0
		}
		
		result = append(result, line)
	}
	
	return strings.Join(result, "\n")
}

func (v *Vendorer) updateBuildZigContent(content string, lockFile *manifest.LockFile, projectManifest *manifest.Manifest) (string, error) {
	content = v.removeAutoGeneratedContent(content)

	if len(lockFile.Package) == 0 {
		return content, nil
	}
	
	lines := strings.Split(content, "\n")
	var result []string
	
	yukiImportAdded := false
	dependenciesAdded := false
	exeVarName := "exe"

	exeRegex := regexp.MustCompile(`const\s+(\w+)\s+=\s+b\.addExecutable`)
	
	for _, line := range lines {
		if matches := exeRegex.FindStringSubmatch(line); len(matches) > 1 {
			exeVarName = matches[1]
		}
		
		if !yukiImportAdded && strings.Contains(line, `@import("std")`) && strings.Contains(line, "const") {
			result = append(result, line)
			result = append(result, `const yuki = @import("yuki.zig");`)
			yukiImportAdded = true
			continue
		}
		
		if !dependenciesAdded && 
		   (strings.Contains(line, "b.installArtifact") || 
		    strings.Contains(line, fmt.Sprintf("b.installArtifact(%s)", exeVarName))) {
			result = append(result, "")
			result = append(result, "    // Auto-generated dependencies by Yuki")
			
			allDeps := projectManifest.GetAllDependencies()
			
			for _, pkg := range lockFile.Package {
				moduleName := sanitizeModuleName(pkg.Name)
				rootFile := v.determineRootFile(pkg.Name, allDeps, projectManifest)
				importPath := fmt.Sprintf("%s/%s/%s", VendorDir, pkg.Name, rootFile)
				result = append(result, fmt.Sprintf("    %s.root_module.addImport(\"%s\", b.createModule(.{", 
					exeVarName, moduleName))
				result = append(result, fmt.Sprintf("        .root_source_file = b.path(\"%s\"),", importPath))
				result = append(result, "    }));")
			}
			
			dependenciesAdded = true
		}
		
		result = append(result, line)
	}
	
	return strings.Join(result, "\n"), nil
}

func (v *Vendorer) generateYukiZigContent(lockFile *manifest.LockFile, projectManifest *manifest.Manifest) string {
	var sb strings.Builder
	
	sb.WriteString("// Auto-generated file by Yuki package manager\n")
	sb.WriteString("// Do not edit this file directly\n\n")
	
	if len(lockFile.Package) == 0 {
		sb.WriteString("// No dependencies\n")
		return sb.String()
	}

	allDeps := projectManifest.GetAllDependencies()
	
	for _, pkg := range lockFile.Package {
		moduleName := sanitizeModuleName(pkg.Name)

		rootFile := v.determineRootFile(pkg.Name, allDeps, projectManifest)
		importPath := fmt.Sprintf("%s/%s/%s", VendorDir, pkg.Name, rootFile)
		
		sb.WriteString(fmt.Sprintf("pub const %s = @import(\"%s\");\n", 
			moduleName, importPath))
	}
	
	sb.WriteString("\n// Dependency list\n")
	sb.WriteString("pub const dependencies = .{\n")
	for _, pkg := range lockFile.Package {
		moduleName := sanitizeModuleName(pkg.Name)
		sb.WriteString(fmt.Sprintf("    .%s = %s,\n", moduleName, moduleName))
	}
	sb.WriteString("};\n")
	return sb.String()
}

func (v *Vendorer) determineRootFile(dependencyName string, allDeps map[string]manifest.Dependency, projectManifest *manifest.Manifest) string {
	if dep, exists := allDeps[dependencyName]; exists && dep.RootFile != "" {
		return dep.RootFile
	}

	if projectManifest.Package.RootFile != "" {
		return projectManifest.Package.RootFile
	}

	return "src/main.zig"
}

func sanitizeModuleName(name string) string {
	result := strings.ReplaceAll(name, "-", "_")
	result = strings.ReplaceAll(result, ".", "_")
	result = strings.ReplaceAll(result, "/", "_")
	return result
}

func extractRepoName(gitURL string) string {
	if strings.HasPrefix(gitURL, "https://github.com/") {
		parts := strings.Split(strings.TrimPrefix(gitURL, "https://github.com/"), "/")
		if len(parts) >= 2 {
			repo := parts[1]
			if strings.HasSuffix(repo, ".git") {
				repo = repo[:len(repo)-4]
			}
			return fmt.Sprintf("%s/%s", parts[0], repo)
		}
	}
	return gitURL
}

func (v *Vendorer) Clean(projectRoot string) error {
	vendorPath := filepath.Join(projectRoot, VendorDir)
	yukiZigPath := filepath.Join(projectRoot, YukiZigFile)

	if err := os.RemoveAll(vendorPath); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to remove vendor directory: %w", err)
	}

	if err := os.Remove(yukiZigPath); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to remove yuki.zig: %w", err)
	}
	
	if err := v.cleanBuildZig(projectRoot); err != nil {
		logger.Warn("Failed to clean build.zig: %v", err)
	}
	
	logger.Info("Cleaned vendor directory and generated files")
	return nil
}

func (v *Vendorer) cleanBuildZig(projectRoot string) error {
	buildZigPath := filepath.Join(projectRoot, BuildZigFile)

	if _, err := os.Stat(buildZigPath); os.IsNotExist(err) {
		return nil // Nothing to clean
	}

	content, err := os.ReadFile(buildZigPath)
	if err != nil {
		return fmt.Errorf("failed to read build.zig: %w", err)
	}

	cleanedContent := v.removeAutoGeneratedContent(string(content))

	cleanedContent = v.fixCorruptedBuildZig(cleanedContent)
	
	if err := os.WriteFile(buildZigPath, []byte(cleanedContent), 0644); err != nil {
		return fmt.Errorf("failed to write cleaned build.zig: %w", err)
	}

	return nil
}

func (v *Vendorer) fixCorruptedBuildZig(content string) string {
	lines := strings.Split(content, "\n")
	var result []string
	
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		
		// Skip orphaned closing brackets
		if trimmed == "}));" || trimmed == "});" {
			// Check if this line is actually part of a complete statement
			// by looking at the previous lines
			if len(result) > 0 {
				prevLine := strings.TrimSpace(result[len(result)-1])
				if !strings.Contains(prevLine, ".addImport") && 
				   !strings.Contains(prevLine, ".createModule") &&
				   !strings.Contains(prevLine, "b.path(") {
					continue
				}
			} else {
				continue
			}
		}
		
		result = append(result, line)
	}
	
	return strings.Join(result, "\n")
}

func (v *Vendorer) RemovePackageFiles(projectRoot, packageName string) error {
	packagePath := filepath.Join(projectRoot, VendorDir, packageName)
	
	if _, err := os.Stat(packagePath); os.IsNotExist(err) {
		logger.Debug("Package directory '%s' doesn't exist", packagePath)
		return nil
	}
	
	if err := os.RemoveAll(packagePath); err != nil {
		return fmt.Errorf("failed to remove package directory '%s': %w", packagePath, err)
	}
	
	logger.Debug("Removed package directory '%s'", packagePath)
	return nil
}

func copyDir(src, dst string) error {
	return filepath.Walk(src, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		relPath, err := filepath.Rel(src, path)
		if err != nil {
			return err
		}
		dstPath := filepath.Join(dst, relPath)
		
		if info.IsDir() {
			return os.MkdirAll(dstPath, info.Mode())
		}

		return copyFile(path, dstPath)
	})
}

func copyFile(src, dst string) error {
	sourceFile, err := os.ReadFile(src)
	if err != nil {
		return err
	}
	
	if err := os.MkdirAll(filepath.Dir(dst), 0755); err != nil {
		return err
	}
	
	return os.WriteFile(dst, sourceFile, 0644)
}

func (v *Vendorer) ListVendoredDependencies(projectRoot string) ([]string, error) {
	vendorPath := filepath.Join(projectRoot, VendorDir)
	
	entries, err := os.ReadDir(vendorPath)
	if err != nil {
		if os.IsNotExist(err) {
			return []string{}, nil
		}
		return nil, err
	}
	
	var deps []string
	for _, entry := range entries {
		if entry.IsDir() {
			deps = append(deps, entry.Name())
		}
	}
	
	return deps, nil
}