package utils

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"

	"yuki_zpm.org/manifest"
)

func IsHexString(s string) bool {
	for _, c := range s {
		if !((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')) {
			return false
		}
	}
	return true
}

func GenerateCacheKey(owner, repo string, dep manifest.Dependency) string {
	var parts []string
	parts = append(parts, owner, repo)
	
	if dep.Rev != "" {
		parts = append(parts, "rev", dep.Rev)
	} else if dep.Tag != "" {
		parts = append(parts, "tag", dep.Tag)
	} else if dep.Branch != "" {
		parts = append(parts, "branch", dep.Branch)
	} else if dep.Version != "" {
		parts = append(parts, "version", dep.Version)
	} else if dep.UseLatestCommit {
		parts = append(parts, "latest-commit")
	} else {
		parts = append(parts, "latest")
	}
	
	return strings.Join(parts, "-")
}

func CheckGitAvailable() error {
	_, err := exec.LookPath("git")
	if err != nil {
		return fmt.Errorf("git is not installed or not available in PATH")
	}
	return nil
}

func CreateProjectStructure(projectRoot, projectName, rootFile string) error {
	rootFileDir := filepath.Dir(rootFile)
	if rootFileDir != "." {
		fullDir := filepath.Join(projectRoot, rootFileDir)
		if err := os.MkdirAll(fullDir, 0755); err != nil {
			return err
		}
	}

	mainZigContent := fmt.Sprintf(`const std = @import("std");

pub fn main() !void {
    std.log.info("Hello from %s!", .{"%s"});
}

test "basic test" {
    try std.testing.expectEqual(2 + 2, 4);
}
`, projectName, projectName)

	mainZigPath := filepath.Join(projectRoot, rootFile)
	if err := os.WriteFile(mainZigPath, []byte(mainZigContent), 0644); err != nil {
		return err
	}

	buildZigContent := fmt.Sprintf(`const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const exe = b.addExecutable(.{
        .name = "%s",
        .root_source_file = b.path("%s"),
        .target = target,
        .optimize = optimize,
    });

    b.installArtifact(exe);

    const run_cmd = b.addRunArtifact(exe);
    run_cmd.step.dependOn(b.getInstallStep());

    if (b.args) |args| {
        run_cmd.addArgs(args);
    }

    const run_step = b.step("run", "Run the app");
    run_step.dependOn(&run_cmd.step);

    const unit_tests = b.addTest(.{
        .root_source_file = b.path("%s"),
        .target = target,
        .optimize = optimize,
    });

    const run_unit_tests = b.addRunArtifact(unit_tests);
    const test_step = b.step("test", "Run unit tests");
    test_step.dependOn(&run_unit_tests.step);
}
`, projectName, rootFile, rootFile)

	buildZigPath := filepath.Join(projectRoot, "build.zig")
	if err := os.WriteFile(buildZigPath, []byte(buildZigContent), 0644); err != nil {
		return err
	}

	yukiZigContent := `// Auto-generated file by Yuki package manager
// Do not edit this file directly

// No dependencies
`

	yukiZigPath := filepath.Join(projectRoot, "yuki.zig")
	if err := os.WriteFile(yukiZigPath, []byte(yukiZigContent), 0644); err != nil {
		return err
	}

	return nil
}

func DetectZigVersion() string {
	cmd := exec.Command("zig", "version")
	output, err := cmd.Output()
	if err != nil {
		return ""
	}

	version := strings.TrimSpace(string(output))
	
	// Handle different Zig version formats
	// Examples: "0.12.0", "0.13.0-dev.123+abc123", "0.11.0"
	
	// Extract base version (major.minor.patch)
	re := regexp.MustCompile(`^(\d+\.\d+\.\d+)`)
	matches := re.FindStringSubmatch(version)
	if len(matches) > 1 {
		return matches[1]
	}

	devRe := regexp.MustCompile(`^(\d+)\.(\d+)\.\d+-dev`)
	devMatches := devRe.FindStringSubmatch(version)
	if len(devMatches) > 2 {
		return fmt.Sprintf("%s.%s.0", devMatches[1], devMatches[2])
	}
	return version
}

func ValidateAndSanitizeRootFile(rootFile string) (string, error) {
	cleaned := filepath.Clean(rootFile)

	if strings.Contains(cleaned, "..") {
		return "", fmt.Errorf("root file cannot reference parent directories")
	}
	
	if filepath.IsAbs(cleaned) {
		return "", fmt.Errorf("root file must be a relative path")
	}

	if !strings.HasSuffix(cleaned, ".zig") {
		return "", fmt.Errorf("root file must be a .zig file")
	}

	cleaned = strings.ReplaceAll(cleaned, "\\", "/")
	
	return cleaned, nil
}

